%%%% Proceedings format for most of ACM conferences (with the exceptions listed below) and all ICPS volumes.
\documentclass[sigconf]{acmart}
%%%% As of March 2017, [siggraph] is no longer used. Please use sigconf (above) for SIGGRAPH conferences.

%%%% Proceedings format for SIGPLAN conferences 
% \documentclass[sigplan, anonymous, review]{acmart}

%%%% Proceedings format for SIGCHI conferences
% \documentclass[sigchi, review]{acmart}

%%%% To use the SIGCHI extended abstract template, please visit
% https://www.overleaf.com/read/zzzfqvkmrfzn


\usepackage{booktabs} % For formal tables
\usepackage{indentfirst}


% Copyright 
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
%\acmDOI{10.475/123_4}

% ISBN
%\acmISBN{123-4567-24-567/08/06}

%Conference
%\acmConference[WOODSTOCK'97]{ACM Woodstock conference}{July 1997}{El
  %Paso, Texas USA}
%\acmYear{1997}
%\copyrightyear{2016}


%\acmArticle{4}
%\acmPrice{15.00}

\begin{document}
\title{Temp Title: Non-Functional Bugs Project}
%\titlenote{Produces the permission block, and
  %copyright information}


\author{Aida Radu}
\affiliation{
  \institution{Dept. of Computing Science \\ University of Alberta}
  \city{Edmonton}
  \state{Canada}
}
\email{aradu@ualberta.ca}

\author{Sarah Nadi}
\affiliation{
  \institution{Dept. of Computing Science \\ University of Alberta}
  \city{Edmonton}
  \country{Canada}
}
\email{nadi@ualberta.ca}


\begin{abstract}
[PLACEHOLDER TEXT]

\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm

\begin{CCSXML}
	<ccs2012>
	<concept>
	<concept_id>10011007</concept_id>
	<concept_desc>Software and its engineering</concept_desc>
	<concept_significance>500</concept_significance>
	</concept>
    
	<concept>
	<concept_id>10011007.10010940.10011003</concept_id>
	<concept_desc>Software and its engineering~Extra-functional properties</concept_desc>
	<concept_significance>500</concept_significance>
	</concept>
	</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering}
\ccsdesc[500]{Software and its engineering~Extra-functional properties}


\keywords{Repository Mining; Bug Detection}


\maketitle

% ---------------------------------------------------------------------------------------------------
\section{Introduction}
% ---------------------------------------------------------------------------------------------------
\section{Background}
% ---------------------------------------------------------------------------------------------------
\section{Methodology}
To create our dataset, we looked at a variety of Github repositories written in either java or python. 
We used two main methods to identify candidate repositories for mining. 
 
\subsection{Initial Procedure}
First, we used the Github API to search for projects written in java or python, and sorted them based on their number of stars. We then selected the top 80 repositories from these results. 

\subsubsection{Obtaining commits}
To extract commits related to non-functional requirements, we implemented a keyword search using PyDriller \footnote{https://github.com/ishepard/pydriller, Davide Spadini 2018}. The stemmed keywords are listed in Table 1. Example word endings are in square brackets.

% --------------- TABLE -------------
\begin{table}
  \caption{Commit Message Keywords}
  \label{tab:kwds}
\begin{tabular}{  c c c }
\toprule
 "fix"&"bug"&"error"\\
 "refactor"&"secur[ity]" &"maint[enance]"\\
 "stab[ility]"&"portab[ility]"&"efficien[cy]"\\
 "usab[ility]" & "reliab[ility]"&"testab[ility]"\\
 "changeab[ility]"& "replace"&"memory"\\
 "resource"& "runtime"&"crash"\\
 "leak" &"attack" &"authenticat[ion]"\\
 "authoriz]ation]"& "cipher"&"crack" \\ 
 "decrypt"&"encrypt"&"vulnerab[ility]"\\ 
 "minimize"&"optimize"&"slow"\\
 "\#"& &\\
\bottomrule
\end{tabular}
\end{table}
% --------------- TABLE -------------

For those repositories identified by star rating, we directly ran PyDriller; note that some of these projects contained zero true positives. 
Our PyDriller program mined the commit history of each project, and outputted a CSV file containing the id and message of the commits containing one or more of the keywords in Table \ref{tab:kwds}. For projects written in Java, we further limited our search to commits affecting \texttt{.java} files. Likewise, for python projects, we looked at \texttt{.py} files.

We then manually searched these files for true positives. We ignored commits that, despite containing one or more of the keywords in our list, did not relate to non-functional requirements (e.g., ``Fix copy paste error''\footnote{https://github.com/jenkinsci/jenkins/commit/9fb6ccf} and ``Allow modules to replace visual character representation''\footnote{https://github.com/MovingBlocks/Terasology/commit/45f915a}). Furthermore, we did not include problems that were highly specific to the given project. 

\subsubsection{Documentation} 
For each problem we identified, we recorded the problem meta data in a YAML\footnote{http://yaml.org/, last checked on June 27, 2018} file. Figure \ref{fig:meta1} shows an example of our format. Each file contains the problem's \texttt{commit url} and \texttt{commit message}, as well as the particular \texttt{file} and \texttt{method} where developers made the fix. Because a user`s commit message is not always thorough, we explained our interpretation of the problem under a \texttt{description} field. For fixes related to specific APIs (e.g., using a StringBuilder in place of  a String), we recorded the involved \texttt{API}, as well as a \texttt{rule} corresponding to the change. For commits not connected to a particular API, we created a general \texttt{suggestion} to address similar problems. An example of this type is shown in Figure \ref{fig:meta2}. In addition, we assigned a tag to each problem according to the type of fix: security, performance, or memory.

% --------------- FIGURE -------------
\begin{figure}
\includegraphics[height=2in, width=3in]{YAMLmetadata}
\caption{Meta Data for \texttt{Fowler} - problem 2}
\label{fig:meta1}
\end{figure}
% --------------- FIGURE -------------


% --------------- FIGURE -------------
\begin{figure}
\includegraphics[height=2in, width=3in]{YAMLmetadata2}
\caption{Meta Data for \texttt{VISNodeWS} - problem 1}
\label{fig:meta2}
\end{figure}
% --------------- FIGURE -------------

\subsection{Alternate Procedure}
Using our first method, we found several instances where developers corrected memory leaks, or replaced one API with another to improve performance. Thus, for our second method, we identified candidate repos using Github`s search bar to find similar changes. We searched for commits containing the keywords in Table \ref{tab:kwds}. As well, we searched for language-specific enhancements such as ``StringBuilder replace,'' and ``foreach loop replace.'' We documented the bug that was found in the search using the format in Figures \ref{fig:meta1} and \ref{fig:meta2}. We then ran PyDriller on the complete repo history. Thus, these projects always had at least one true positive. Once we ran PyDriller, the method was identical to that in the previous section.

\section{Dataset}


Using the first procedure, we mined [NUMBER] repositories. Of these, [NUMBER] contained true positives. In total, we identified [NUMBER]  problems using this method. Using the second procedure, we obtained a total of [NUMBER] problems from [NUMBER] repositories. The distribution of problems by type and language is shown in Table \ref{tab:type}TALK]. The number of problems per tag are displayed in \ref{tab:tag}[TALK]. Table \ref{tab:domain} shows the number of projects in our dataset that have stars,watches, and forks within a given range	[TALK].

% --------------- TABLE -------------
\begin{table}
  \caption{Data Distribution}
  \label{tab:type}
\begin{tabular}{  c c c c}
\toprule
  Problem Type&	Python&Java & Total\\
 \midrule
 API &			17  &  44 &   62\\
 General &		12   &  17 &  31\\
 Other &		1   &  3  &   4\\
 \midrule
  Total&		30 &  64 &   94\\
\bottomrule
\end{tabular}
\end{table}
% --------------- TABLE -------------

% because some have two tags, these have to be separate tables, otherwise the totals wouldn't add up
% --------------- TABLE -------------
\begin{table}
  \caption{Data Distribution by Problem Tag}
  \label{tab:tag}
\begin{tabular}{  c c c c }
\toprule
  Tag & Python&Java & Total\\
 \midrule
security&9 &16 & 25\\
performance&12 &30&42 \\
memory&4 &23 & 27 \\
resource management&1 &5&6 \\


\bottomrule
\end{tabular}
\end{table}
% --------------- TABLE -------------

% --------------- TABLE -------------
\begin{table}
  \caption{Number of Projects by Github Stats}
  \label{tab:domain}
\begin{tabular}{  c c c c }
\toprule
  Range & stars & watches & forks\\
 \midrule
0&		 22 &9& 22\\
1-100&   9 &42& 21\\
101-500& 10 &6 &12\\
500-1000&9 &0 &0\\
>1000   & 10 & 2&5\\

\bottomrule
\end{tabular}
\end{table}
% --------------- TABLE -------------

\section{Discussion and Directions for Future Work}
\section{Conclusions}
\section*{threats to validity}


\section*{Acknowledgements}


\bibliographystyle{ACM-Reference-Format}
\bibliography{bibRaduNadi2018}

\end{document}

