REPO: JENKINS https://github.com/jenkinsci/jenkins
--------------------------------------------------

In Repository: Jenkins
Commit ID: fe21d5c1414da04ba92344665f339889be3cb3dd
Message: fixed a horrible horrible memory leak.

Relevant Changes: line 40 
Diff:
40a41
>         channel.pendingCalls.remove(id);

Description: Programmers added a call to release some memory that had previously been abandoned

________________

In Repository: Jenkins 
Commit ID:3f0b72e1c116f8cc0107a2afa8c481e4730e789a
Message: moving dependency computation logic to a single place to improve efficiency.
Relevant Changes: lines 0-130 in DependencyGraph.java
Diff:
> import hudson.model.DependencyGraph;
> import hudson.model.Hudson;
97c99
<     public List<MavenModule> getDownstreamProjects() {
---
>     protected void buildDependencyGraph(DependencyGraph graph) {
99d100
<         return Collections.emptyList();
118a120,122
> 
>         // dependency setting might have been changed by the user, so rebuild.
>         Hudson.getInstance().rebuildDependencyGraph();
22d21
< import java.util.ArrayList;
354c353,355
<     public abstract List<? extends AbstractProject> getDownstreamProjects();
---
>     public final List<AbstractProject> getDownstreamProjects() {
>         return Hudson.getInstance().getDependencyGraph().getDownstream(this);
>     }
356,362c357,358
<     public List<AbstractProject> getUpstreamProjects() {
<         List<AbstractProject> r = new ArrayList<AbstractProject>();
<         for( AbstractProject p : Hudson.getInstance().getAllItems(AbstractProject.class) ) {
<             if(p.getDownstreamProjects().contains(this))
<                 r.add(p);
<         }
<         return r;
---
>     public final List<AbstractProject> getUpstreamProjects() {
>         return Hudson.getInstance().getDependencyGraph().getUpstream(this);
401a398,403
> 
>     /**
>      * Builds the dependency graph.
>      * @see DependencyGraph
>      */
>     protected abstract void buildDependencyGraph(DependencyGraph graph);
0a1,130
> package hudson.model;
> 
> import java.util.ArrayList;
> import java.util.Collection;
> import java.util.Collections;
> import java.util.Comparator;
> import java.util.HashMap;
> import java.util.List;
> import java.util.Map;
> import java.util.Map.Entry;
> 
> /**
>  * Maintains the build dependencies between {@link AbstractProject}s
>  * for efficient dependency computation.
>  *
>  * <p>
>  * The "master" data of dependencies are owned/persisted/maintained by
>  * individual {@link AbstractProject}s, but because of that, it's relatively
>  * slow  to compute backward edges.
>  *
>  * <p>
>  * This class builds the complete bi-directional dependency graph
>  * by collecting information from all {@link AbstractProject}s.
>  *
>  * <p>
>  * Once built, {@link DependencyGraph} is immutable, and every time
>  * there's a change (which is relatively rare), a new instance
>  * will be created. This eliminates the need of synchronization.
>  *
>  * @author Kohsuke Kawaguchi
>  */
> public final class DependencyGraph {
> 
>     private Map<AbstractProject, List<AbstractProject>> forward = new HashMap<AbstractProject, List<AbstractProject>>();
>     private Map<AbstractProject, List<AbstractProject>> backward = new HashMap<AbstractProject, List<AbstractProject>>();
> 
>     private boolean built;
> 
>     /**
>      * Builds the dependency graph.
>      */
>     public DependencyGraph() {
>         for( AbstractProject p : Hudson.getInstance().getAllItems(AbstractProject.class) )
>             p.buildDependencyGraph(this);
> 
>         forward = finalize(forward);
>         backward = finalize(backward);
> 
>         built = true;
>     }
> 
>     /**
>      * Special constructor for creating an empty graph
>      */
>     private DependencyGraph(boolean dummy) {
>         forward = backward = Collections.emptyMap();
>         built = true;
>     }
> 
>     /**
>      * Gets all the immediate downstream projects (IOW forward edges) of the given project.
>      *
>      * @return
>      *      can be empty but never null.
>      */
>     public List<AbstractProject> getDownstream(AbstractProject p) {
>         return get(forward,p);
>     }
> 
>     /**
>      * Gets all the immediate upstream projects (IOW backward edges) of the given project.
>      *
>      * @return
>      *      can be empty but never null.
>      */
>     public List<AbstractProject> getUpstream(AbstractProject p) {
>         return get(backward,p);
>     }
> 
>     private List<AbstractProject> get(Map<AbstractProject, List<AbstractProject>> map, AbstractProject src) {
>         List<AbstractProject> v = map.get(src);
>         if(v!=null) return v;
>         else        return Collections.emptyList();
>     }
> 
>     /**
>      * Called during the dependency graph build phase to add a dependency edge.
>      */
>     public void addDependency(AbstractProject from, AbstractProject to) {
>         if(built)
>             throw new IllegalStateException();
>         add(forward,from,to);
>         add(backward,to,from);
>     }
> 
>     public void addDependency(AbstractProject from, Collection<? extends AbstractProject> to) {
>         for (AbstractProject p : to)
>             addDependency(from,p);
>     }
> 
>     public void addDependency(Collection<? extends AbstractProject> from, AbstractProject to) {
>         for (AbstractProject p : from)
>             addDependency(p,to);
>     }
> 
>     private void add(Map<AbstractProject, List<AbstractProject>> map, AbstractProject src, AbstractProject dst) {
>         List<AbstractProject> set = map.get(src);
>         if(set==null) {
>             set = new ArrayList<AbstractProject>();
>             map.put(src,set);
>         }
>         set.add(dst);
>     }
> 
>     private Map<AbstractProject, List<AbstractProject>> finalize(Map<AbstractProject, List<AbstractProject>> m) {
>         for (Entry<AbstractProject, List<AbstractProject>> e : m.entrySet()) {
>             Collections.sort( e.getValue(), NAME_COMPARATOR );
>             e.setValue( Collections.unmodifiableList(e.getValue()) );
>         }
>         return Collections.unmodifiableMap(m);
>     }
> 
>     private static final Comparator<AbstractProject> NAME_COMPARATOR = new Comparator<AbstractProject>() {
>         public int compare(AbstractProject lhs, AbstractProject rhs) {
>             return lhs.getName().compareTo(rhs.getName());
>         }
>     };
> 
>     public static final DependencyGraph EMPTY = new DependencyGraph(false);
> }
124a125,126
>     private transient volatile DependencyGraph dependencyGraph = DependencyGraph.EMPTY;
> 
803a806
>         rebuildDependencyGraph();
1339a1343,1353
>     }
> 
>     /**
>      * Rebuilds the dependency map.
>      */
>     public void rebuildDependencyGraph() {
>         dependencyGraph = new DependencyGraph();
>     }
> 
>     public DependencyGraph getDependencyGraph() {
>         return dependencyGraph;
134c134
<     public List<AbstractProject> getDownstreamProjects() {
---
>     protected void buildDependencyGraph(DependencyGraph graph) {
136,139c136,137
<         if(buildTrigger==null)
<             return new ArrayList<AbstractProject>();
<         else
<             return buildTrigger.getChildProjects();
---
>         if(buildTrigger!=null)
>              graph.addDependency(this,buildTrigger.getChildProjects());
215c213,216
<         Hudson.getInstance().getQueue().scheduleMaintenance();  
---
>         Hudson.getInstance().getQueue().scheduleMaintenance();
> 
>         // dependency setting might have been changed by the user, so rebuild.
>         Hudson.getInstance().rebuildDependencyGraph();


Description: Programmers added a class to use for building and maintaining a di-graph instead of finding back edges whenever accessing a node. This reduces runtime and improves efficiency, maintainability.
_______________


In Repository: Jenkins
Commit ID: 9793a71e28163a2ad948b8e905acf4e6cb95dc01
Message: improved error diagnostics.
Relevant Changes: line 115
Diff:


2a3,4
> import hudson.util.IOException2;
> 
115,116c117,122
<         File f = File.createTempFile(prefix, suffix, getLocal());
<         return new FilePath(this,f.getName());
---
>         try {
>             File f = File.createTempFile(prefix, suffix, getLocal());
>             return new FilePath(this,f.getName());
>         } catch (IOException e) {
>             throw new IOException2("Failed to create a temp file on "+getLocal(),e);
>         }

Description: Programmers added exception handling for if a file could not be created; this improves the security, integrity, and performance of the program

________________


In Repository: Jenkins
Commit ID: 66b9d9baaf6877be2bc14962aeb5c4bfb1c82ff5
Message: fixed a possible security issue (SECURITY-3)


Relevant Changes: line 122
Diff:
122a123
>                     if (getRequestorType()!=RequestorType.PROXY)    return null;

Description: Programmers ensured a process would terminate if the proxy was invalid, which improves security of the application.
_______________

In Repository: Jenkins
Commit ID: 1bdecb463bed8db59d556d403a5cee7d5d87d182
Message: getItemByFullName shouldn't bypass security check


Relevant Changes: line 2097
Diff:
2097a2098,2100
>             if (!item.hasPermission(Item.READ))
>                 return null;


Description: Programmers improved security by adding a permission check to a variable
_______________


In Repository: Jenkins
Commit ID: 1ff064187b485d39860fdc0eaa201fe90f9155fc
Message: fixed a security hole


Relevant Changes: line 436
Diff:
3a4
> import hudson.model.Hudson;
436a438,439
>         if(!Hudson.adminCheck(req,rsp))
>             return;
440a444,445
>         if(!Hudson.adminCheck(req,rsp))
>             return;
5c5
< <l:layout>
---
> <l:layout secured="true">

Description:
Programmers ensured a function terminated if admin requirements were not met. This was to improve security of the application. 

________________


In Repository: Jenkins
Commit ID: 9eb6cee10a9c982493b6a0256c4c32b9e95853ee
Message: Fixed a security issue. The security should be on by default. (#926)
Relevant Changes: line 31
Diff:
31c31
<         if(token==null || token.authorizedToStartBuild(req,rsp)) {
---
>         if(!Hudson.getInstance().isUseSecurity() || (token!=null && token.authorizedToStartBuild(req,rsp))) {

Description: The change improves security by ensuring a check for security is always done.

_______________

In Repository: Jenkins
Commit ID: d0a6643b10aba58f31956bbb9bba4b824955e5e8
Message: more testability improvements.
Relevant Changes: line 61
Diff:
322c322
<       <version>1.107</version>
---
>       <version>1.108</version>
32,33c32,34
< import org.kohsuke.stapler.StaplerRequest;
< import org.kohsuke.stapler.StaplerResponse;
---
> import org.kohsuke.stapler.HttpResponse;
> import org.kohsuke.stapler.HttpRedirect;
> import org.kohsuke.stapler.QueryParameter;
61,62c62,63
<     public void doAct(StaplerRequest req, StaplerResponse rsp) throws IOException {
<         if(req.hasParameter("no")) {
---
>     public HttpResponse doAct(@QueryParameter boolean no) throws IOException {
>         if(no) {
64c65
<             rsp.sendRedirect(req.getContextPath()+"/manage");
---
>             return HttpRedirect.fromContextPath("/manage");
66c67
<             rsp.sendRedirect(".");
---
>             return new HttpRedirect(".");

Description: Programmers added more exceptions to improve testing and error handling

________________


In Repository: Jenkins
Commit ID: b46bf8b2b4dd56fb0fa41c4d98a0a8cadd4ae191
Message: implemented a fix for the data-loss problem.
Relevant changes: line 144
Diff:
45a46,52
>  *
>  * <h2>Persistence</h2>
>  * <p>
>  * {@link Descriptor} can persist data just by storing them in fields.
>  * However, it is the responsibility of the derived type to properly
>  * invoke {@link #save()} and {@link #load()}.
>  *
66c73,75
<         load();
---
>         // doing this turns out to be very error prone,
>         // as field initializers in derived types will override values.
>         // load();
82c91
<      *      Always non-null. This object includes all the submitted form values. 
---
>      *      Always non-null. This object includes all the submitted form values.
144,145c153,156
<     private void load() {
<         // load
---
>     /**
>      * Loads the data from the disk into this object.
>      */
>     protected synchronized void load() {
523a524
>             load();
419a420
>             load();
109a110
>             load();
293a294
>             load();
110a111
>             load();
103a104
>             load();
140a141
>             load();

Description: Programmers improved data integrity by synchronizing a method so data is not accidentally overwritten

________________


In Repository: Jenkins
Commit ID: feaf22ae84130bd1f280de08f9c20531edb92f73
Message: improved the error diagnostics when authentication is not set up in the container.
Relevant changes: line 1059
Diff:
1059c1059,1062
<         rsp.sendRedirect2(req.getContextPath()+"/");
---
>         if(req.getUserPrincipal()==null)
>             rsp.sendRedirect2("noPrincipal");
>         else
>             rsp.sendRedirect2(".");
0a1,12
> <!-- there seems to be no authentication -->
> <j:jelly xmlns:j="jelly:core" xmlns:st="jelly:stapler" xmlns:d="jelly:define" xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form">
>   <l:layout>
>     <st:include page="sidepanel.jelly" />
>     <l:main-panel>
>       <div style="margin: 2em; color:red; font-weight:bold">
>         The web container doesn't seem to be configured to do authentication.
>         Check the container documentation and/or also consult <tt>users@hudson.dev.java.net</tt>
>       </div>
>     </l:main-panel>
>   </l:layout>
> </j:jelly>


Description: Programmers improved security by adding error handling for a scenario where a container has no valid authentication

________________

In Repository: Jenkins
Commit ID: 46339e1043244a63dc855c3f66473f7329f16671
Message: fixed #478 "anonymous user should not be able to tag sources"
Relevant changes: line 1039
Diff:
1039a1040,1041
>             if(tagName==null && !Hudson.isAdmin())
>                 return null;
1044c1046,1051
<             return "Tag this build";
---
>             if(tagName==null)
>                 return "Tag this build";
>             if(tagName.indexOf(' ')>=0)
>                 return "CVS tags";
>             else
>                 return "CVS tag";
1078a1086,1088
>             if(!Hudson.adminCheck(req,rsp))
>                 return;
> 
1125a1136,1138
>             if(!Hudson.adminCheck(req,rsp))
>                 return;
> 
Description: Programmers improved security by making sure that anonymous users don’t have the same permissions as admins

________________

In Repository: Jenkins
Commit ID: c1a629781ea3dca96159207d559d540e71b09943
Message: fixed a FileReader leak.
Relevant changes: line 202
Diff:
192,201c192,203
<             String line;
<             while((line=br.readLine())!=null) {
<                 int index = line.lastIndexOf('/');
<                 if(index<0) {
<                     continue;   // invalid line?
<                 }
<                 try {
<                     revisions.put(line.substring(0,index), Long.parseLong(line.substring(index+1)));
<                 } catch (NumberFormatException e) {
<                     // perhaps a corrupted line. ignore
---
>             try {
>                 String line;
>                 while((line=br.readLine())!=null) {
>                     int index = line.lastIndexOf('/');
>                     if(index<0) {
>                         continue;   // invalid line?
>                     }
>                     try {
>                         revisions.put(line.substring(0,index), Long.parseLong(line.substring(index+1)));
>                     } catch (NumberFormatException e) {
>                         // perhaps a corrupted line. ignore
>                     }
202a205,206
>             } finally {
>                 br.close();


Description: Preventing data corruption by remembering to close a file when finished

________________


In Repository: Jenkins
Commit ID: 0ff8353b2bd1a0e3ff8dd6086704a31a3f6078ce
Message: I am quite sure I had a good reason for wanting the length of a masked portion of a command to be equal to the length of the thing that is masked... but for the life of me I cannot remember why.  Making all masks have fixed length to provide less information to password snoopers

Relevant changes: line 259
Diff:
259c259
<                 masked[i] = "********************************************************".substring(0, cmd[i].length());
---
>                 masked[i] = "********";

Description: Programmers improved security by ensuring commands couldn’t be guessed from their length.
________________

In Repository: Jenkins
Commit ID: 05901476a3b096002dee33e3f6a1cd02b0876579
Message: improved efficiency
Relevant changes: line 26
Diff:
6a7,8
> import java.io.Reader;
> import java.io.IOException;
26c28
<     public String getLog() {
---
>     public Reader readAll() throws IOException {
28c30
<         return log.toString();
---
>         return text.readAll();
15a16
>       <pre><st:copyStream reader="${it.workerThread.readAll()}" /></pre>

Description:  makes the program more efficient by using a previously defined function and returning a Reader
________________


In Repository: Jenkins
Commit ID: 5f1a706201b4d8507dd56e65c65963213d178c60
Message: [fixed 1.206] make sure to close changelog.xml more rigorously to prevent problems like #1509
Relevant changes: 
Diff:
26a27
> import org.apache.commons.io.IOUtils;
681a683
>         OutputStream o = null;
686c688
<             final OutputStream out = new RemoteOutputStream(new FileOutputStream(changelogFile));
---
>             final OutputStream out = o = new RemoteOutputStream(new FileOutputStream(changelogFile));
724c726,727
<                     task.setDeststream(new BufferedOutputStream(out));
---
>                     BufferedOutputStream bufferedOutput = new BufferedOutputStream(out);
>                     task.setDeststream(bufferedOutput);
751a755,756
>                     } finally {
>                         bufferedOutput.close();
779a785,786
>         } finally {
>             IOUtils.closeQuietly(o);

Description: Prevents data corruption by ensuring files don’t remain open at termination
________________

In Repository: Jenkins
Commit ID: 1c698565fa3886f0c5fa6ea999af2802e8eee2ce
Message: fixed a stream leak
Relevant changes: line 150
Diff:
150,155c150,160
<             String firstLine = new BufferedReader(new FileReader(archive)).readLine();
<             if(firstLine.startsWith("Manifest-Version:")) {
<                 // this is the manifest already
<             } else {
<                 // indirection
<                 archive = resolve(archive, firstLine);
---
>             BufferedReader archiveReader = new BufferedReader(new FileReader(archive));
>             try {
>                 String firstLine = archiveReader.readLine();
>                 if(firstLine.startsWith("Manifest-Version:")) {
>                     // this is the manifest already
>                 } else {
>                     // indirection
>                     archive = resolve(archive, firstLine);
>                 }
>             } finally {
>                 archiveReader.close();

Description: Preventing data corruption by remembering to close a file at termination

________________

In Repository: Jenkins
Commit ID: 137c90cc612ddb3a51d050be298dcd2e0ae86a4c
Message: [FIXED JENKINS-24080] Improved security of CommandDuringBuild and its current implementations
Relevant changes: line 34,69
Diff:
66a67,69
>   <li class="bug">
>     Improving security of <code>set-build-parameter</code> and <code>set-build-result</code> CLI commands.
>     (<a href="https://issues.jenkins-ci.org/browse/JENKINS-24080">issue 24080</a>)
69a70,72
>                 if (!r.isBuilding()) {
>                     throw new CmdLineException(r + " is not currently being built");
>                 }
34a35
>         r.checkPermission(Run.UPDATE);
51c51
<         r.getParent().checkPermission(Item.BUILD);
---
>         r.checkPermission(Run.UPDATE);
6a7
> import hudson.model.Result
44a46,51
>         assert r.equals(["a":"x", "b":"y"]);
> 
>         p.buildersList.add(new Shell("BUILD_NUMBER=1 java -jar cli.jar set-build-parameter a b"));
>         def b2 = j.assertBuildStatus(Result.FAILURE, p.scheduleBuild2(0).get());
>         r = [:];
>         b.getAction(ParametersAction.class).parameters.each { v -> r[v.name]=v.value }


Description: Programmers ensured necessary permissions were granted before proceeding

