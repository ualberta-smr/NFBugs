REPO: JENKINS https://github.com/jenkinsci/jenkins
--------------------------------------------------

REPO: JENKINS https://github.com/jenkinsci/jenkins
--------------------------------------------------

In Repository: Jenkins
Commit ID: fe21d5c1414da04ba92344665f339889be3cb3dd
Message: fixed a horrible horrible memory leak.

Relevant Changes: lines 
Diff:
40a41
>         channel.pendingCalls.remove(id);

Description: Programmers added a call to release some memory that had previously been abandoned

________________

In Repository: Jenkins 
Commit ID:3f0b72e1c116f8cc0107a2afa8c481e4730e789a
Message: moving dependency computation logic to a single place to improve efficiency.
Relevant Changes: lines 0-130 in DependencyGraph.java
Diff:
> import hudson.model.DependencyGraph;
> import hudson.model.Hudson;
97c99
<     public List<MavenModule> getDownstreamProjects() {
---
>     protected void buildDependencyGraph(DependencyGraph graph) {
99d100
<         return Collections.emptyList();
118a120,122
> 
>         // dependency setting might have been changed by the user, so rebuild.
>         Hudson.getInstance().rebuildDependencyGraph();
22d21
< import java.util.ArrayList;
354c353,355
<     public abstract List<? extends AbstractProject> getDownstreamProjects();
---
>     public final List<AbstractProject> getDownstreamProjects() {
>         return Hudson.getInstance().getDependencyGraph().getDownstream(this);
>     }
356,362c357,358
<     public List<AbstractProject> getUpstreamProjects() {
<         List<AbstractProject> r = new ArrayList<AbstractProject>();
<         for( AbstractProject p : Hudson.getInstance().getAllItems(AbstractProject.class) ) {
<             if(p.getDownstreamProjects().contains(this))
<                 r.add(p);
<         }
<         return r;
---
>     public final List<AbstractProject> getUpstreamProjects() {
>         return Hudson.getInstance().getDependencyGraph().getUpstream(this);
401a398,403
> 
>     /**
>      * Builds the dependency graph.
>      * @see DependencyGraph
>      */
>     protected abstract void buildDependencyGraph(DependencyGraph graph);
0a1,130
> package hudson.model;
> 
> import java.util.ArrayList;
> import java.util.Collection;
> import java.util.Collections;
> import java.util.Comparator;
> import java.util.HashMap;
> import java.util.List;
> import java.util.Map;
> import java.util.Map.Entry;
> 
> /**
>  * Maintains the build dependencies between {@link AbstractProject}s
>  * for efficient dependency computation.
>  *
>  * <p>
>  * The "master" data of dependencies are owned/persisted/maintained by
>  * individual {@link AbstractProject}s, but because of that, it's relatively
>  * slow  to compute backward edges.
>  *
>  * <p>
>  * This class builds the complete bi-directional dependency graph
>  * by collecting information from all {@link AbstractProject}s.
>  *
>  * <p>
>  * Once built, {@link DependencyGraph} is immutable, and every time
>  * there's a change (which is relatively rare), a new instance
>  * will be created. This eliminates the need of synchronization.
>  *
>  * @author Kohsuke Kawaguchi
>  */
> public final class DependencyGraph {
> 
>     private Map<AbstractProject, List<AbstractProject>> forward = new HashMap<AbstractProject, List<AbstractProject>>();
>     private Map<AbstractProject, List<AbstractProject>> backward = new HashMap<AbstractProject, List<AbstractProject>>();
> 
>     private boolean built;
> 
>     /**
>      * Builds the dependency graph.
>      */
>     public DependencyGraph() {
>         for( AbstractProject p : Hudson.getInstance().getAllItems(AbstractProject.class) )
>             p.buildDependencyGraph(this);
> 
>         forward = finalize(forward);
>         backward = finalize(backward);
> 
>         built = true;
>     }
> 
>     /**
>      * Special constructor for creating an empty graph
>      */
>     private DependencyGraph(boolean dummy) {
>         forward = backward = Collections.emptyMap();
>         built = true;
>     }
> 
>     /**
>      * Gets all the immediate downstream projects (IOW forward edges) of the given project.
>      *
>      * @return
>      *      can be empty but never null.
>      */
>     public List<AbstractProject> getDownstream(AbstractProject p) {
>         return get(forward,p);
>     }
> 
>     /**
>      * Gets all the immediate upstream projects (IOW backward edges) of the given project.
>      *
>      * @return
>      *      can be empty but never null.
>      */
>     public List<AbstractProject> getUpstream(AbstractProject p) {
>         return get(backward,p);
>     }
> 
>     private List<AbstractProject> get(Map<AbstractProject, List<AbstractProject>> map, AbstractProject src) {
>         List<AbstractProject> v = map.get(src);
>         if(v!=null) return v;
>         else        return Collections.emptyList();
>     }
> 
>     /**
>      * Called during the dependency graph build phase to add a dependency edge.
>      */
>     public void addDependency(AbstractProject from, AbstractProject to) {
>         if(built)
>             throw new IllegalStateException();
>         add(forward,from,to);
>         add(backward,to,from);
>     }
> 
>     public void addDependency(AbstractProject from, Collection<? extends AbstractProject> to) {
>         for (AbstractProject p : to)
>             addDependency(from,p);
>     }
> 
>     public void addDependency(Collection<? extends AbstractProject> from, AbstractProject to) {
>         for (AbstractProject p : from)
>             addDependency(p,to);
>     }
> 
>     private void add(Map<AbstractProject, List<AbstractProject>> map, AbstractProject src, AbstractProject dst) {
>         List<AbstractProject> set = map.get(src);
>         if(set==null) {
>             set = new ArrayList<AbstractProject>();
>             map.put(src,set);
>         }
>         set.add(dst);
>     }
> 
>     private Map<AbstractProject, List<AbstractProject>> finalize(Map<AbstractProject, List<AbstractProject>> m) {
>         for (Entry<AbstractProject, List<AbstractProject>> e : m.entrySet()) {
>             Collections.sort( e.getValue(), NAME_COMPARATOR );
>             e.setValue( Collections.unmodifiableList(e.getValue()) );
>         }
>         return Collections.unmodifiableMap(m);
>     }
> 
>     private static final Comparator<AbstractProject> NAME_COMPARATOR = new Comparator<AbstractProject>() {
>         public int compare(AbstractProject lhs, AbstractProject rhs) {
>             return lhs.getName().compareTo(rhs.getName());
>         }
>     };
> 
>     public static final DependencyGraph EMPTY = new DependencyGraph(false);
> }
124a125,126
>     private transient volatile DependencyGraph dependencyGraph = DependencyGraph.EMPTY;
> 
803a806
>         rebuildDependencyGraph();
1339a1343,1353
>     }
> 
>     /**
>      * Rebuilds the dependency map.
>      */
>     public void rebuildDependencyGraph() {
>         dependencyGraph = new DependencyGraph();
>     }
> 
>     public DependencyGraph getDependencyGraph() {
>         return dependencyGraph;
134c134
<     public List<AbstractProject> getDownstreamProjects() {
---
>     protected void buildDependencyGraph(DependencyGraph graph) {
136,139c136,137
<         if(buildTrigger==null)
<             return new ArrayList<AbstractProject>();
<         else
<             return buildTrigger.getChildProjects();
---
>         if(buildTrigger!=null)
>              graph.addDependency(this,buildTrigger.getChildProjects());
215c213,216
<         Hudson.getInstance().getQueue().scheduleMaintenance();  
---
>         Hudson.getInstance().getQueue().scheduleMaintenance();
> 
>         // dependency setting might have been changed by the user, so rebuild.
>         Hudson.getInstance().rebuildDependencyGraph();


Description: Programmers added a class to use for building and maintaining a di-graph instead of finding back edges whenever accessing a node. This reduces runtime and improves efficiency, maintainability.
_______________


In Repository: Jenkins
Commit ID: 9793a71e28163a2ad948b8e905acf4e6cb95dc01
Message: improved error diagnostics.
Relevant Changes: lines 
Diff:


2a3,4
> import hudson.util.IOException2;
> 
115,116c117,122
<         File f = File.createTempFile(prefix, suffix, getLocal());
<         return new FilePath(this,f.getName());
---
>         try {
>             File f = File.createTempFile(prefix, suffix, getLocal());
>             return new FilePath(this,f.getName());
>         } catch (IOException e) {
>             throw new IOException2("Failed to create a temp file on "+getLocal(),e);
>         }

Description: Programmers added exception handling for if a file could not be created; this improves the security, integrity, and performance of the program

________________


In Repository: Jenkins
Commit ID: 66b9d9baaf6877be2bc14962aeb5c4bfb1c82ff5
Message: fixed a possible security issue (SECURITY-3)


Relevant Changes: lines 
Diff:
122a123
>                     if (getRequestorType()!=RequestorType.PROXY)    return null;

Description: Programmers ensured a process would terminate if the proxy was invalid, which improves security of the application.
_______________

In Repository: Jenkins
Commit ID: 1bdecb463bed8db59d556d403a5cee7d5d87d182
Message: getItemByFullName shouldn't bypass security check


Relevant Changes: line
Diff:
2097a2098,2100
>             if (!item.hasPermission(Item.READ))
>                 return null;


Description: Programmers improved security by adding a permission check to a variable
_______________


In Repository: Jenkins
Commit ID: 1ff064187b485d39860fdc0eaa201fe90f9155fc
Message: fixed a security hole


Relevant Changes: line 
Diff:
3a4
> import hudson.model.Hudson;
436a438,439
>         if(!Hudson.adminCheck(req,rsp))
>             return;
440a444,445
>         if(!Hudson.adminCheck(req,rsp))
>             return;
5c5
< <l:layout>
---
> <l:layout secured="true">

Description:
Programmers ensured a function terminated if admin requirements were not met. This was to improve security of the application. 

________________


In Repository: Jenkins
Commit ID: 9eb6cee10a9c982493b6a0256c4c32b9e95853ee
Message: Fixed a security issue. The security should be on by default. (#926)
Relevant Changes: line 31
Diff:
31c31
<         if(token==null || token.authorizedToStartBuild(req,rsp)) {
---
>         if(!Hudson.getInstance().isUseSecurity() || (token!=null && token.authorizedToStartBuild(req,rsp))) {

Description: The change improves security by ensuring a check for security is always done.

_______________

In Repository: Jenkins
Commit ID: d0a6643b10aba58f31956bbb9bba4b824955e5e8
Message: more testability improvements.
Relevant Changes: line 61
Diff:
322c322
<       <version>1.107</version>
---
>       <version>1.108</version>
32,33c32,34
< import org.kohsuke.stapler.StaplerRequest;
< import org.kohsuke.stapler.StaplerResponse;
---
> import org.kohsuke.stapler.HttpResponse;
> import org.kohsuke.stapler.HttpRedirect;
> import org.kohsuke.stapler.QueryParameter;
61,62c62,63
<     public void doAct(StaplerRequest req, StaplerResponse rsp) throws IOException {
<         if(req.hasParameter("no")) {
---
>     public HttpResponse doAct(@QueryParameter boolean no) throws IOException {
>         if(no) {
64c65
<             rsp.sendRedirect(req.getContextPath()+"/manage");
---
>             return HttpRedirect.fromContextPath("/manage");
66c67
<             rsp.sendRedirect(".");
---
>             return new HttpRedirect(".");

Description: Programmers added more exceptions to improve testing and error handling
